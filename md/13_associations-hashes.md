<!DOCTYPE html>
<html lang="en-GB">
    <!-- scheme notes by NewForester is licensed under a Creative Commons Attribution-ShareAlike 4.0 International Licence. -->
<head>
    <meta charset="UTF-8" />
    <meta name="description" content="Notes on the Yet Another Scheme Introduction tutorial" />
    <meta name="keywords" content="Scheme" />
    <meta name="author" content="NewForester" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../styles/style-sheet.css" />

    <title>Scheme Notes: Association Lists and Hash Tables</title>
</head>

<body>
# Scheme

## Association Lists and Hash Tables

Lists and numbers are the most commonly used data types in Scheme but there are others.

<hr /><!-- Association Lists -->

In Scheme, associative data are pairs of (unique) keys and values.
Association lists (aka lists of associative data) are part of R<sub>5</sub>RS but search time is linear (<i>O(n)</i>).

MIT-Scheme also provides hash tables.
These are not part of the standard but are faster (<i>O(1)</i>).

Both are faster when the keys are symbols and not strings.

Association lists consist of either `dot pairs` (aka `cons` pairs) or ordinal lists.
In the first case, the keys are the left hand of each pair (the `car`).
In the second case, they keys are the first item of each list.

There are three functions to search such lists, `assq`, `assv`, `assoc` that, respectively, use `eq?`, `eqv?` and `equal?`.
Each returns the `dot pair` or ordinal list that matches key or `'()` otherwise.

```scheme
    (define wc '((hi . 3) (everybody . 5) (nice . 3) (to . 10) (meet . 4) (you . 8)))
    ⇒  wc
    (assq 'hi wc)
    ⇒  (hi . 3)
    (assq 'you wc)
    ⇒  (you . 8)
    (assq 'i wc)
    ⇒  ()

    (define n '((1 2 3) (4 5 6) (7 8 9)))
    ⇒  n
    (assv 1 n)
    ⇒  (1 2 3)
    (assv 8 n)
    ⇒  ()
```

<hr /><!-- Hash Tables -->

Hash tables use a hash function to convert the key into a hash address,
which is used to decide where to store data in the table and also where to retrieve it from.

When the hash table is not crowded, access is constant (<i>O(1)</i>).

MIT-Scheme provides the following functions:

```scheme
    (make-eq-hash-table size)           ; create hash table with `eq?` as key comparator
    (make-eqv-hash-table size)          ; create hash table with `eqv?` as key comparator
    (make-equal-hash-table size)        ; create hash table with `equal?` as key comparator
    (make-string-hash-table size)       ; create hash table with `string=?` as key comparator
                                        ; size is the initial table size and is optional

    (hash-table/put! hash-table key datum)      ; put datum into table using key
    (hash-table/get hash-table key default)     ; retrieve datum from table using keys
                                                ; return default is key not found

    (hash-table->alist hash-table)      ; convert hash-table into an association list.
```

<hr /><!-- Password Generator -->

The lesson ends with a long example split into two that uses a hash table and association lists.
The example is a password generator [lesson13-example2.scm](../scm/lesson13-example2.scm)
seeded from character pair frequency counts generated by code in [lesson13-example1.scm](../scm/lesson13-example1.scm).

The first half was corrupt and had to be fixed before use.
Our main changes were:

  * split the read and write halves out from the main routine
  * changed the output dataset name from a hard-coded literal to a parameter.

The dataset is a Scheme data structure so it is loaded (not read) into the second half.
The second half was good.
Our main changes were:

  * load the dataset within the password generator
  * changed the dataset name from a hard-coded literal to a parameter.

</body>
</html>
