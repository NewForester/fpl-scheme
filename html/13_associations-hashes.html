<!DOCTYPE html>
<html lang="en-GB">
    <!-- scheme notes by NewForester is licensed under a Creative Commons Attribution-ShareAlike 4.0 International Licence. -->
<head>
    
<meta charset="UTF-8" /> <meta name="description" content="Notes on the Yet Another Scheme Introduction tutorial" /> <meta name="keywords" content="Scheme" /> <meta name="author" content="NewForester" /> <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <link rel="stylesheet" href="../styles/style-sheet.css" />
<title>
Scheme Notes: Association Lists and Hash Tables
</title>
</head>

<body>
<h1 id="scheme">Scheme</h1>
<h2 id="association-lists-and-hash-tables">Association Lists and Hash Tables</h2>
<p>Lists and numbers are the most commonly used data types in Scheme but there are others.</p>
<hr /><!-- Association Lists -->

<p>In Scheme, associative data are pairs of (unique) keys and values. Association lists (aka lists of associative data) are part of R<sub>5</sub>RS but search time is linear (<i>O(n)</i>).</p>
<p>MIT-Scheme also provides hash tables. These are not part of the standard but are faster (<i>O(1)</i>).</p>
<p>Both are faster when the keys are symbols and not strings.</p>
<p>Association lists consist of either <code>dot pairs</code> (aka <code>cons</code> pairs) or ordinal lists. In the first case, the keys are the left hand of each pair (the <code>car</code>). In the second case, they keys are the first item of each list.</p>
<p>There are three functions to search such lists, <code>assq</code>, <code>assv</code>, <code>assoc</code> that, respectively, use <code>eq?</code>, <code>eqv?</code> and <code>equal?</code>. Each returns the <code>dot pair</code> or ordinal list that matches key or <code>'()</code> otherwise.</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">    (<span class="kw">define</span><span class="fu"> wc </span>&#39;((hi . <span class="dv">3</span>) (everybody . <span class="dv">5</span>) (nice . <span class="dv">3</span>) (to . <span class="dv">10</span>) (meet . <span class="dv">4</span>) (you . <span class="dv">8</span>)))
    ⇒  wc
    (<span class="kw">assq</span> &#39;hi wc)
    ⇒  (hi . <span class="dv">3</span>)
    (<span class="kw">assq</span> &#39;you wc)
    ⇒  (you . <span class="dv">8</span>)
    (<span class="kw">assq</span> &#39;i wc)
    ⇒  ()

    (<span class="kw">define</span><span class="fu"> n </span>&#39;((<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>) (<span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>) (<span class="dv">7</span> <span class="dv">8</span> <span class="dv">9</span>)))
    ⇒  n
    (<span class="kw">assv</span> <span class="dv">1</span> n)
    ⇒  (<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)
    (<span class="kw">assv</span> <span class="dv">8</span> n)
    ⇒  ()</code></pre>
<hr /><!-- Hash Tables -->

<p>Hash tables use a hash function to convert the key into a hash address, which is used to decide where to store data in the table and also where to retrieve it from.</p>
<p>When the hash table is not crowded, access is constant (<i>O(1)</i>).</p>
<p>MIT-Scheme provides the following functions:</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">    (make-eq-hash-table size)           <span class="co">; create hash table with `eq?` as key comparator</span>
    (make-eqv-hash-table size)          <span class="co">; create hash table with `eqv?` as key comparator</span>
    (make-equal-hash-table size)        <span class="co">; create hash table with `equal?` as key comparator</span>
    (make-string-hash-table size)       <span class="co">; create hash table with `string=?` as key comparator</span>
                                        <span class="co">; size is the initial table size and is optional</span>

    (hash-table/put! hash-table key datum)      <span class="co">; put datum into table using key</span>
    (hash-table/get hash-table key default)     <span class="co">; retrieve datum from table using keys</span>
                                                <span class="co">; return default is key not found</span>

    (hash-table-&gt;alist hash-table)      <span class="co">; convert hash-table into an association list.</span></code></pre>
<hr /><!-- Password Generator -->

<p>The lesson ends with a long example split into two that uses a hash table and association lists. The example is a password generator <a href="../scm/lesson13-example2.scm">lesson13-example2.scm</a> seeded from character pair frequency counts generated by code in <a href="../scm/lesson13-example1.scm">lesson13-example1.scm</a>.</p>
<p>The first half was corrupt and had to be fixed before use. Our main changes were:</p>
<ul>
<li>split the read and write halves out from the main routine</li>
<li>changed the output dataset name from a hard-coded literal to a parameter.</li>
</ul>
<p>The dataset is a Scheme data structure so it is loaded (not read) into the second half. The second half was good. Our main changes were:</p>
<ul>
<li>load the dataset within the password generator</li>
<li>changed the dataset name from a hard-coded literal to a parameter.</li>
</ul>
</body>
</html>


